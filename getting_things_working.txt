Goal: get a kilobot simulator working in a web browser for which we can write normal c code (that would normally compile down into a hex) and have each robot in the swarm run that code.

Using a web browser suggests using javaScript. 

We will use Emscripten which is a way to compile C code so that it can be called by JavaScript

Emscripten:
https://emscripten.org/docs/introducing_emscripten/about_emscripten.html

more info:
https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Emscripten


------------------------------------ UBUNTU -------------------------------------
Installing Emscripten (on ubuntu):
https://emscripten.org/docs/getting_started/downloads.html


--- install ubuntu prerequisites ----
it looks like we need to install the following prerequisites 
(the first 2 were already installed for me):


# Install Python
sudo apt-get install python2.7

# Install CMake (optional, only needed for tests and building Binary)
sudo apt-get install cmake

# Install Java (optional, only needed for Closure Compiler minification)
sudo apt-get install default-jre

# Install git
sudo apt-get install git-core

--- install the Emscripten SDK ----

Go to the directory where you want to install this stuff, I did this in the directory containing this readme
cd [where you want]

# Get the emsdk repo
git clone https://github.com/emscripten-core/emsdk.git

# Enter that directory
cd emsdk

# Fetch the latest version of the emsdk (not needed the first time you clone)
git pull

# Download and install the latest SDK tools.
./emsdk install latest

# Make the "latest" SDK "active" for the current user. (writes ~/.emscripten file)
./emsdk activate latest

# Activate PATH and other environment variables in the current terminal
source ./emsdk_env.sh

### NOTES git pull will fetch the current list of tags, but very recent ones may not yet be present there. 
### You can run ./emsdk update-tags to update the list of tags directly.
### 
### If you change the location of the SDK (e.g. take it to another computer on an USB), 
### re-run the ./emsdk activate latest and source ./emsdk_env.sh commands.


---- updating the sdk (if some time has passed since the install ----

# Fetch the latest registry of available tools.
./emsdk update

# Download and install the latest SDK tools.
./emsdk install latest

# Set up the compiler configuration to point to the "latest" SDK.
./emsdk activate latest

# Activate PATH and other environment variables in the current terminal
source ./emsdk_env.sh

----- Hello World Example -------


# note, we'll need to run
source [path to the following]/emsdk_env.sh
# every time we boot up, or add this to our bashrc script

# If you haven’t run Emscripten before, run it now with:
emcc -v

## put the following into hello_world.c
## -------------------->

/*
 * Copyright 2011 The Emscripten Authors.  All rights reserved.
 * Emscripten is available under two separate licenses, the MIT license and the
 * University of Illinois/NCSA Open Source License.  Both these licenses can be
 * found in the LICENSE file.
 */

#include <stdio.h>

int main() {
  printf("hello, world!\n");
  return 0;
}

## <-------------------

## go to the directory where  hello_world.c it exits

cd [wherever]

# To build the JavaScript version of this code, simply specify the C/C++ file after emcc (use em++ to force compilation as C++):
./emcc hello_world.c

### You should see two files generated by that command: a.out.js and a.out.wasm. The second is a WebAssembly file containing the compiled code, and the first is a JavaScript file containing the runtime support to load and execute it. You can run them using node.js:

node a.out.js


# Generating HTML
# Emscripten can also generate HTML for testing embedded JavaScript. To generate HTML, use the -o (output) command and specify an html file as the target file:
emcc hello_world.c -o hello.html


# start a local webserver in the directory (Python 3 does this as below, which worked for me):
python -m SimpleHTTPServer

# (if that does not work then try python 2? is: python -m http.server)


# in a browser:
http://localhost:8000/hello.html


# ----------------------------- OPEN GL (WEBGL) example -------------------
[NOTE: this one did not work, so probably skip it]

https://blog.scottlogic.com/2014/03/12/native-code-emscripten-webgl-simmer-gently.html

I checked out the git code and put it into emscripten_webgl_simmer_gently

cd [into that directory]

emcc main.cpp shaders.cpp -s FULL_ES2=1 -o glcore.js

# Inastall typescript (an extension of javaScript used in this tutorial

npm install -g typescript

# translate triangle.js to JavaScript:
tsc triangle.ts --out triangle.js

# compile main
emcc main.cpp shaders.cpp -s FULL_ES2=1 -s EXPORTED_FUNCTIONS=['_initGL','_drawTriangle'] -o glcore.js

[this appeared not to work]



# ----------------------------- ANOTHER OPEN GL (WEBGL) example -------------------
[NOTE: this *did* work, so probably skip it]


https://github.com/timhutton/opengl-canvas-wasm

#Clone this repo:
git clone https://github.com/timhutton/opengl-canvas-wasm.git

# go into the folder
cd opengl-canvas-wasm

# Build index.js and index.wasm:
emcc main.cpp -std=c++11 -s WASM=1 -s USE_SDL=2 -O3 -o index.js


[this did work]


# ----------------------- installing google chrome in ubuntu ----------------------------
# installing chrome is necessary because firefox and other browsers has disabled 
# SharedArrayBuffer (which is necessary for pthreads) due to "Spectre" set of vulnerabilities

# get the chrome .deb from: https://www.google.com/chrome/
# this gave me the file "google-chrome-stable_current_amd64.deb"
# which I copied to a folder, then in that folder and in a terminal:

sudo apt install ./google-chrome-stable_current_amd64.deb

# enable SharedArrayBuffer in chrome by putting the following into the search bar:
chrome://flags/#enable-webassembly-threads



NOTE: if you use chrome for other things then you need to turn this option back off after you are done for the day so that you Chrome is not vulnerable to a Spectre attack. I suggest running the simulation in Chrome and using Firefox or some other browser to surf the web while Chrome has SharedArrayBuffer turned on.

# ----------------------- quick start for working on code ----------------------------


# start python webserver (in one terminal):
python -m SimpleHTTPServer 8080 

# compile code (in another terminal)
source ../emsdk/emsdk_env.sh


# [this has been replaced by what is below] emcc main.cpp -std=c++11 -s WASM=1 -s USE_SDL=2 -O3 -o index.js
# [this has been replaced by what is below] emcc main.cpp -std=c++11 -s USE_PTHREADS=1 -s WASM=1 -s USE_SDL=2 -O3 -o index.js
# [this has been replaced by what is below]  emcc main.cpp -std=c++11 -s USE_PTHREADS=1 -s WASM=1 -s USE_SDL=2 -O3 -o index.js --embed-file light_patterns

emcc main.cpp -std=c++11 -s WASM=1 -s USE_SDL=2 -O3 -o index.js --embed-file light_patterns

# in a google chrome browser:
http://localhost:8080/index.html










